============ Multi Threading / Concurrency ======

        /*TIP Press <shortcut actionId="ShowIntentionActions"/> with your caret at the highlighted text
         to see how IntelliJ IDEA suggests fixing it.*/

//        for (int i = 1; i <= 5; i++) {
//            //TIP Press <shortcut actionId="Debug"/> to start debugging your code. We have set one <icon src="AllIcons.Debugger.Db_set_breakpoint"/> breakpoint
//            // for you, but you can always add more by pressing <shortcut actionId="ToggleLineBreakpoint"/>.
//            System.out.println("i = " + i);
//            Queue<Integer> tes = new PriorityQueue<>();
//        }

//        List<Employee> list = new ArrayList<>();
//        list.add(new Employee(1, "DK"));
//        list.add(new Employee(2, "JK"));
//        list.add(new Employee(2, "BK"));
//        list.add(new Employee(2, "CK"));
////        Collections.sort(list);
//        list.sort(Comparator.comparing(Employee::getName));
//        list.stream().sorted(Comparator.comparing(Employee::getName)).forEach(System.out::println);
//        System.out.println(list);


//        Thread oddThread = new Thread(() -> {
//            for (int i = 1; i < 10; i+=2) {
//                System.out.println(Thread.currentThread().getName());
//                System.out.println(i);
//            }
//        }, "oddThread");
//
//        System.out.println(Thread.currentThread().getName());
//        Thread evenThread = new EvenThread("evenThread");
//        evenThread.start();
//        oddThread.start();
//        System.out.println(Thread.currentThread().getName());
//        System.out.println("Finish");

===== THREAD ======

CommonClass commonClass = new CommonClass();

Thread bankThread1 = new Thread(() -> {
    try {
        commonClass.deposit(4000);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
}, "thread 1");

Thread bankThread2 = new Thread(() -> {
    try {
        commonClass.withdraw(3000);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
}, "thread 2");

bankThread1.start();
bankThread2.start();


    ======== Generic / Functional Programming=======

        List<String> list = new ArrayList<>(List.of("a", "b", "c", "d", "e", "f", "g", "h"));
//        list.add("i");

        list.forEach(System.out::println);

        // this will be the implementation of any BiFunction
        BiFunction<MethodReference, Integer, String> test = MethodReference::testThis;

        // execution of above
        System.out.println(test.apply(new MethodReference(), 1));


//        BinaryOperator<String> p1 = ();

        Function<Integer, String> fn = (a) -> "This is " + a;
        //

        // inner will be executed first, final output should be Integer and input will be String
        Function<Integer, String> res = fn.compose((Integer a) -> 5 + a);

        System.out.println(res.apply(6));

        // inside function input will be string, res will be the final Function return type String output of the last call, and input will be the input of the fn Integer
        Function<Integer, String> res2 = fn.andThen((String a) -> "I am the Mind-blowing and Believer" + a);

        System.out.println(res2.apply(5));


============ Trie DS =====


======= Generics ======

//        TrieExercise.Node root = new TrieExercise.Node();
//        TrieExercise.insertTrieWord(root, "apple");
//        TrieExercise.insertTrieWord(root, "cat");
//        TrieExercise.insertTrieWord(root, "ball");
//        TrieExercise.insertTrieWord(root, "zebra");
//        TrieExercise.insertTrieWord(root, "elephant");
//        TrieExercise.insertTrieWord(root, "dog");
//
//        List<String> res = new ArrayList<>();
//
//        // print, it will print in sorted form, time complexity - O(L), L = length of all words
//        TrieExercise.printWords(root, -1, new StringBuilder(), res);
//        System.out.println(res);
//
//        // Searching, time complexity - O(L), L = length of input word
//        System.out.println(TrieExercise.searchWord(root, "hello"));
//        System.out.println(TrieExercise.searchWord(root, "apple"));

        // Rank is to identify the major item out of given options
        // parent stores the value belonging to same group

//        DSU dsu = new DSU(5);
//        dsu.union(0, 1);
//        dsu.union(2, 3);
//        dsu.union(3, 0);
//        dsu.union(1, 4);
//        System.out.println("parent:" + Arrays.toString(dsu.parent));
//        System.out.println("rank:" + Arrays.toString(dsu.rank));
//
//        DSU_Pract dsu2 = new DSU_Pract(5);
//        dsu2.union(0, 1);
//        dsu2.union(2, 3);
//        dsu2.union(3, 0);
//        dsu2.union(1, 4);
//        System.out.println("parent:" + Arrays.toString(dsu2.parent));
//        System.out.println("rank:" + Arrays.toString(dsu2.rank));

        // implementation of the Function -> apply method
//        Function<Integer, Float> fun = (x) -> x / 2.3f;
//
//        Float res = fun.apply(6);
//        System.out.println(res);
//
//        // Predicate / Supplier / Consumer
//
//        Predicate<String> predicate = new Predicate<String>() {
//            @Override
//            public boolean test(String s) {
//                return s.equals("Hello");
//            }
//        };
//
//        System.out.println(predicate.test("Hello"));
//
//        // supplier
//        Supplier<String> supplier = () -> "Hello There!";
//        System.out.println(supplier.get());
//
//        // Consumer
//        StringBuilder str = new StringBuilder("Hello");
//        Consumer<String> consumer = s -> {
//            String test = str.toString() + s;
//            str.append(test);
//        };
//        consumer.accept(" Bro");
//        System.out.println(str);
//
//        Consumer<String> cons_1 = s -> System.out.println("Hello" + s);
//        Consumer<String> cons_2 = s -> System.out.println("Post" + s);
//
//        Consumer<String> res_2 = cons_1.andThen(cons_2);
//        res_2.accept("DK");

//        Function<Integer, String> composedFn = (a) -> "This is " + a; // <V, T>
//        // returns of the composedFn = String, that would be the input of this fun
//        Function<String, Boolean> thisFun = str -> str.contains("This is 20"); // <T, R>
//
//        // now return of the thisFun will be the final Output type
//        // now the final fun apply return type -> <V, R> = <Integer, Boolean>
//
//        Function<Integer, Boolean> newFun = thisFun.compose(composedFn); // <V, R>
//
//        System.out.println(newFun.apply(20));
//
//        // =========
//        Function<Integer, String> thisFun2 = a -> "This is " + a; // <T, R>
//
//        Function<String, Boolean> thenAppFun = (str) -> str.contains("This is 20"); // <R, V>
//
//        Function<Integer, Boolean> newFun2 = thisFun2.andThen(thenAppFun); // <T, V>
//
//        System.out.println(newFun2.apply(30));
//        System.out.println(newFun2.apply(20));
//
//
//        List<? super Integer> list = Arrays.asList(2, 3, 3.5);
//
//        for (Object o: list) {
//            System.out.println(o);
//        }
============ ends ======

